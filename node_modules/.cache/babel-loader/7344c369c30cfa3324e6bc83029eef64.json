{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Sumac\\\\Documents\\\\GitHub\\\\chronovis-paintbox\\\\src\\\\components\\\\Graphic.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, axisLeft, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateIntervals from \"./generateIntervals\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Graphic(_ref) {\n  _s();\n\n  let {\n    data,\n    setData,\n    updateSrc,\n    activeLayer,\n    zones,\n    setZones,\n    radius,\n    info,\n    setInfo,\n    setInflectTarget,\n    showLabel,\n    toggle,\n    setToggle,\n    scales,\n    setScales,\n    syntacticOrder,\n    setSyntacticOrder,\n    activeScale\n  } = _ref;\n  //all data is passed down from and synced to App.js\n  const activeData = Object.entries(data); //convert json to array for faster processing\n\n  const activeZones = Object.entries(zones); //TODO: layers\n  // const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\n  //is logical operators active?\n\n  const logic = data.length ? isNaN(data[0].x) : null; //TODO: refine logical operators\n  //initialize reference object to pass to svg in React Dom\n\n  const svgRef = useRef(); //svg wrapped in div bc otherwise resize observer callback won't work\n\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState(); //hash map of y scales\n\n  const yScales = {}; //init scales. turn into useRef eventually\n\n  useEffect(() => {\n    if (!dimensions) return;\n    const yTicks = [];\n\n    for (let v of activeData) {\n      yTicks.push(activeData.y);\n    }\n\n    Object.entries(scales.y).forEach(_ref2 => {\n      let [k, v] = _ref2;\n      yScales[k] = {\n        scale: scaleLinear().domain([0, dimensions.height]).range([v.min, v.max]),\n        drag: scaleLinear().domain([-dimensions.height, dimensions.height]).range([-(v.max - v.min), v.max - v.min]),\n        ticks: [...new Set(yTicks)]\n      };\n    });\n  }, [dimensions, scales, currentZoomState, data]); //initialize intervals between instants\n\n  const intervals = generateIntervals(data); //TODO: write updateIntervals function\n  //initialize variables\n\n  /*\r\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\r\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\r\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\r\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\r\n  */\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n\n    if (!dimensions) return; //removes svgs added using append()\n\n    svg.selectAll(\".remove\").remove(); //removes\n\n    if (!activeData.length) {\n      svg.selectAll(\".instant\").remove();\n      svg.selectAll(\".interval\").remove();\n      svg.selectAll(\".label\").remove();\n      svg.selectAll(\".intervalLabel\").remove();\n    } else if (!activeZones.length) {\n      svg.selectAll(\".zones\").remove();\n      svg.selectAll(\".zonesLabel\").remove();\n    } //rounding for data inputted thru paintbox interface\n\n\n    function round(value, range) {\n      const precision = Math.log10(range) < 1 ? -Math.floor(Math.log10(range) - 1) : 0;\n      return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);\n    } //---scales---//\n    //if time matches logical operator keyword, translate into index values, then map\n\n\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n    const breakpoint = 5;\n    const xMin = min(activeData.map(_ref3 => {\n      let [key, {\n        x\n      }] = _ref3;\n      return logic ? logicScale(x) : x;\n    }));\n    const xMax = max(activeData.map(_ref4 => {\n      let [key, {\n        x\n      }] = _ref4;\n      return logic ? logicScale(x) : x;\n    })); // const yMin = min(Object.entries(data).map(([key, {y}]) => y));\n    // const yMax = max(Object.entries(data).map(([key, {y}]) => y));\n\n    const yTicks = activeData.map(_ref5 => {\n      let [, {\n        y\n      }] = _ref5;\n      return y;\n    });\n    const yMin = scales.y[activeScale[1]].min;\n    const yMax = scales.y[activeScale[1]].max;\n    const rangeX = xMax - xMin; //0 is minX, 1 is maxX (reference findMinMax)\n\n    const rangeY = yMax - yMin;\n    /*\r\n    - Allow users to specify scale. x&y min max and units label\r\n    - for each scale, generateScale()\r\n    */\n    // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\n    //\n    //   const xInverse = scaleLinear()\n    //     .domain([0, dimensions.width])\n    //     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const xDrag = scaleLinear()\n    //     .domain([-dimensions.width, dimensions.width])\n    //     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const yInverse = scaleLinear()\n    //     .domain([-dimensions.height, dimensions.height])\n    //     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //\n    //\n    //   return {\n    //     xInverse, xDrag, yInverse\n    //   };\n    // }\n\n    const xInverse = currentScale => scaleLinear().domain([0, dimensions.width]).range([currentScale.min, currentScale.max]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n\n    const xDrag = currentScale => scaleLinear().domain([-dimensions.width, dimensions.width]).range([-(currentScale.domain()[1] - currentScale.domain()[0]), currentScale.domain()[1] - currentScale.domain()[0]]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    // const yInverse = scaleLinear()\n    //   .domain([-dimensions.height, dimensions.height])\n    //   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //scales values to screen pixels\n\n    /*\r\n    {\r\n      biggie: {\r\n        ...\r\n        scale: generateScale()\r\n      }\r\n      ...\r\n    }\r\n    */\n\n    /*\r\n    xScale =\r\n    {\r\n    }\r\n    */\n    //TODO: fromEntries & entries not compatible with some older browsers\n\n\n    const xScales = Object.fromEntries( //for every scale in scales data, generate an xScale\n    Object.entries(scales.x).map(_ref6 => {\n      let [key, thisScale] = _ref6;\n      return [key, {\n        scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n        .domain([thisScale.min, thisScale.max]).range([0, dimensions.width]),\n        noBeginning: thisScale.min - 0.1 * (thisScale.max - thisScale.min),\n        noEnd: thisScale.max + 0.1 * (thisScale.max - thisScale.min),\n        hasSegments: thisScale.segments.length ? true : false,\n        hideLabel: thisScale.hideLabel,\n        yPos: 1 - thisScale.yPos,\n        label: `${key} (${thisScale.units})`,\n        tickValues: thisScale.tickValues ? thisScale.tickValues : null,\n        scaleInverse: scaleLinear() //for NewInstantForm\n        .domain([0, dimensions.width]).range([thisScale.min, thisScale.max])\n      }];\n    }));\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales.x).forEach((key, i) => {\n        const thisScale = scales.x[key]; // const segments = [];\n\n        if (!thisScale.segments.length) {\n          return;\n        }\n\n        thisScale.segments.map(n => {\n          const min = n.min ? n.min : thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n\n          const max = n.max ? n.max : thisScale.max; // console.log(xScales[i].scale(min));\n\n          segments.push({\n            scale: key,\n            yPos: 1 - thisScale.yPos,\n            proportion: (max - min) / (thisScale.max - thisScale.min),\n            segment: scaleLinear().domain([min, max]).range([xScales[key].scale(min), xScales[key].scale(max)])\n          });\n        });\n      });\n      return segments;\n    };\n    /*\r\n      xScales(generateScales(scaleLinear(scale)))\r\n      - take xScale and rescale according to transformations (newXScale)\r\n      - update each array entry's domain with that of newXScale\r\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n\n\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(_ref7 => {\n        let [key, thisScale] = _ref7;\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n\n        const newMin = newXScale.domain()[0];\n        const newMax = newXScale.domain()[1]; //applies zoom transformations to scale + scaleInverse\n\n        xScales[key].scale = newXScale;\n      });\n    }\n\n    ; // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n\n    const yScale = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n    // .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n    .domain([yMin, yMax]).range([dimensions.height, 0]); //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n    const yScaleInverse = scaleLinear().domain([0, dimensions.height]).range([yMin, yMax]); // .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\n\n    const yScaleInverseDrag = scaleLinear().domain([dimensions.height, -dimensions.height]).range([-rangeY, rangeY]); // .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n\n    if (Object.entries(zones).length) {\n      svg.selectAll(\".zones\").data(activeZones).join(\"rect\").attr(\"class\", \"zones pointer\").attr(\"x\", _ref8 => {\n        let [, v] = _ref8;\n        return xScales[v.scale[0]].scale(v.start);\n      }) // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      .attr(\"y\", _ref9 => {\n        let [, v] = _ref9;\n        return yScale(yMax);\n      }) // .attr(\"y\", ([, v]) => v.yStart ? yScale(v.yStart) : yMin-10) //TODO: if no yStart, minimum y value\n      .attr(\"width\", _ref10 => {\n        let [, v] = _ref10;\n        return xScales[v.scale[0]].scale(v.end) - xScales[v.scale[0]].scale(v.start);\n      }).attr(\"height\", _ref11 => {\n        let [, v] = _ref11;\n        return yScale(yMin); // if (v.yStart & v.yEnd) {\n        //   return (yScale(v.yStart)-yScale(v.yEnd))\n        // } else if (v.yStart) {\n        //   return (yScale(v.yStart)-yScale(yMax-10))\n        // } else {\n        //   return (yScale(yMax-10)) //TODO: if no yStart, minimum y value\n        //   // return (yScale(minMax[3])-yScale(minMax[2]))\n        // }\n      }).attr(\"opacity\", _ref12 => {\n        let [k, v] = _ref12;\n        return v.opacity ? v.opacity : 0.5;\n      }).attr(\"fill\", _ref13 => {\n        let [k, v] = _ref13;\n        return v.color ? v.color : \"#999\";\n      }).attr(\"stroke\", \"black\") //TODO: stroke be different colors\n      .attr(\"stroke-width\", _ref14 => {\n        let [k, v] = _ref14;\n        return v.importance ? v.importance * 2 : 0;\n      }).on(\"click\", (e, target) => {\n        if (toggle === \"certainty\" || toggle === \"importance\") {\n          //pulls up inflection menu\n          setInflectTarget(target);\n        } else if (toggle !== \"pan\" || toggle !== \"addInstant\") {\n          //displays zone properties when clicked\n          setInfo(null); //clear InfoBox\n\n          setInfo({\n            position: [e.x, e.y],\n            target: target,\n            type: \"zone\",\n            dimensions: dimensions\n          }); //TODO: set info to null when clicking same zone again\n        }\n\n        e.stopPropagation();\n      });\n      svg.selectAll(\".zonesLabel\").data(activeZones).join(\"text\").attr(\"class\", \"zonesLabel\").text(_ref15 => {\n        let [k, v] = _ref15;\n        return v.text;\n      }).attr(\"opacity\", 0.5).attr(\"x\", _ref16 => {\n        let [, v] = _ref16;\n        return xScales[v.scale[0]].scale(v.start) + 10;\n      }).attr(\"y\", yScale(yMax) + 30) //.05 above max y\n      .attr(\"text-anchor\", \"bottom\");\n    } //---draw bottom axis---//\n\n\n    xSegments().forEach(n => {\n      //TODO: push all the axis ticks() values into an array\n      // [...new Set(segments)]\n      //draw from there\n      const segment = axisBottom(n.segment) // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\").tickSize(-dimensions.height); //TODO\n\n      svg.append(\"g\").attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * n.yPos}px)`).call(segment).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n      .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n      .attr(\"stroke-opacity\", 0.25)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10).attr(\"opacity\", (d, i) => {\n        //TODO: remove instead of setting opacity to 0\n        if (n.proportion < .25 && i % 3) {\n          //less than 1/4, label every 3 ticks\n          return 0;\n        } else if (n.proportion < .33 && i % 2) {\n          //less than 1/3, label every other tick\n          return 0;\n        } else {\n          return 0.5;\n        }\n      }));\n    });\n    Object.entries(xScales).forEach(_ref17 => {\n      let [key, thisScale] = _ref17;\n      const xAxis = axisBottom(thisScale.scale).tickValues(thisScale.scale.ticks().concat(scales.x[key].min, scales.x[key].max)) //pass in autogenerated tick values + min and max values\n      .tickFormat(format('')).tickSize(-dimensions.height); // console.log(thisScale.scale.ticks())\n\n      if (!thisScale.hasSegments) {\n        svg.append(\"g\").attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * thisScale.yPos}px)`).call(xAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n        .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n        .attr(\"stroke-opacity\", 0.25)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n        .attr(\"opacity\", 0.5));\n      }\n\n      if (!thisScale.hideLabel) {\n        svg.append(\"text\").text(thisScale.label).attr(\"class\", \"axisLabel smallTxt remove\").attr(\"x\", dimensions.width / 2).attr(\"y\", dimensions.height * (thisScale.yPos + .07)).attr(\"text-anchor\", \"middle\").attr(\"opacity\", 0.5);\n      }\n    }); //--draw vertical axis--//\n\n    const yAxis = axisLeft(yScale).tickValues([...new Set(yTicks), scales.y[activeScale[1]].min, scales.y[activeScale[1]].max]) //reg mode\n    .tickFormat(format(''));\n    svg.append(\"g\").attr(\"class\", \"remove\") // .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n    .call(yAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n    .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n    .attr(\"stroke-opacity\", 0.5)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n    .attr(\"opacity\", 0.5));\n\n    if (!scales.y[activeScale[1]].hideLabels) {\n      svg.append(\"text\").text(`${activeScale[1]} (${scales.y[activeScale[1]].units})`).attr(\"class\", \"axisLabel smallTxt remove\") // .attr(\"x\", dimensions.width/2)\n      // .attr(\"y\", dimensions.height/2)\n      .attr(\"text-anchor\", \"middle\").attr(\"transform\", `translate(-30,${dimensions.height / 2})rotate(-90)`).attr(\"opacity\", 0.5);\n    } //--drag behavior--//\n\n\n    const dragged = drag() // .on(\"start\", e => {\n    //   select(this).attr(\"stroke\", \"black\");\n    // })\n    .on(\"drag\", e => {\n      //TODO: extract precision function to round new pos\n      const dx = xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx); // const dx = xScales.scaleInverse\n\n      const dy = yScaleInverseDrag(e.dy);\n      const newInstants = { ...data\n      }; //always make a copy when updating array\n      //find array element in data with matching ID and set new x y coordinates\n\n      newInstants[e.subject[0]].x += dx;\n      newInstants[e.subject[0]].y += dy;\n      setData(newInstants);\n    }) //TODO: unify onEnd and onClick\n    .on(\"end\", e => {\n      console.log(\"end\");\n    });\n\n    if (activeData.length) {\n      //---draw intervals---//\n      const intervaler = linkHorizontal().source(interval => interval.source[1]).target(interval => interval.target[1]) // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n      .x(v => {\n        const thisScale = xScales[v.scale[0]];\n\n        if (!isNaN(v.x)) {\n          return thisScale.scale(v.x);\n        } else if (v.x === \"noEnd\") {\n          return thisScale.scale(thisScale.noEnd);\n        } else if (v.x === \"noBeginning\") {\n          return thisScale.scale(thisScale.noBeginning);\n        }\n      }).y(v => yScale(v.y));\n      svg.selectAll(\".interval\").data(intervals).join(\"path\").raise().attr(\"class\", \"interval pointer\").attr(\"d\", intervaler).attr(\"fill\", \"none\").attr(\"stroke\", n => n.color ? n.color : \"black\").attr(\"stroke-width\", n => n.width ? n.width : radius).attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1).attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null).on(\"click\", (e, target) => {\n        if (toggle === \"connection\") {\n          const newOrder = [...syntacticOrder];\n\n          if (newOrder[2] === 0) {\n            //set 2nd selection\n            newOrder[1] = {\n              x: xInverse(scales.x[activeScale[0]])(e.layerX),\n              y: yScaleInverse(e.layerY),\n              scale: activeScale\n            }; //scale TODO\n\n            newOrder[2] = 1;\n          } else {\n            //set 1st selection\n            newOrder[0] = {\n              x: xInverse(scales.x[activeScale[0]])(e.layerX),\n              y: yScaleInverse(e.layerY),\n              scale: activeScale\n            };\n            newOrder[2] = 0;\n          }\n\n          setSyntacticOrder(newOrder);\n        } //else if (toggle===\"foreshadowing\") {\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //\n        //\n        //   } else { //otherwise, change mouse to no symbol\n        //\n        //   }\n        //   //option to adjust gradient eventually\n        // } else\n        else if (toggle === \"certainty\" || toggle === \"importance\") {\n          setInflectTarget(target);\n        } else {\n          setInfo(null); //clear InfoBox\n\n          setInfo({\n            position: [e.x, e.y],\n            target: target,\n            type: \"interval\",\n            dimensions: dimensions\n          }); //displays interval properties when clicked\n        }\n\n        e.stopPropagation();\n      }); //---draw instants---//\n\n      svg.selectAll(\".instant\") // .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n      .data(activeData).join(\"circle\").raise().attr(\"class\", \"instant pointer\").attr(\"r\", _ref18 => {\n        let [, v] = _ref18;\n        return v.radius ? v.radius : radius;\n      }) //TODO: custom radius accessibility\n      .attr(\"fill\", _ref19 => {\n        let [, v] = _ref19;\n        return v.color ? v.color : \"black\";\n      }) //if it has a color other than black, use that\n      .attr(\"opacity\", _ref20 => {\n        let [, v] = _ref20;\n        return v.opacity ? v.opacity : 1;\n      }) // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n      .attr(\"cx\", _ref21 => {\n        let [, v] = _ref21;\n        const thisScale = xScales[v.scale[0]];\n        /*\r\n        noBeginning: thisScale.min-10,\r\n        noEnd: thisScale.max+10,\r\n        */\n\n        if (!isNaN(v.x)) {\n          return thisScale.scale(v.x);\n        } else if (v.x === \"noBeginning\") {\n          return thisScale.scale(thisScale.noBeginning);\n        } else if (v.x === \"noEnd\") {\n          return thisScale.scale(thisScale.noEnd);\n        }\n      }) //scale x coordinate based on xScale defined in instant's scale property\n      .attr(\"cy\", _ref22 => {\n        let [, v] = _ref22;\n        return yScale(v.y);\n      }).call(dragged).on(\"click\", (e, target) => {\n        switch (toggle) {\n          case \"cancelled\":\n            const newData = { ...data\n            };\n            newData[target[0]].cancelled = true; // console.log(newData[target[0]]);\n\n            updateSrc(newData);\n            break;\n\n          case \"connection\":\n            const newOrder = [...syntacticOrder];\n\n            if (newOrder[2] === 0) {\n              //set 2nd selection\n              newOrder[1] = target;\n              newOrder[2] = 1;\n            } else {\n              //set 1st selection\n              newOrder[0] = target;\n              newOrder[2] = 0;\n            }\n\n            setSyntacticOrder(newOrder);\n            break;\n\n          case \"foreshadowing\":\n            if (!target.target) {\n              //if target is an endpoint, indeterminate end\n              const newInstants = [...data];\n              const instant = newInstants.find(n => n.id === target.id);\n              instant.foreshadowing = true;\n              setData(newInstants);\n            } else {\n              //otherwise, change mouse to no symbol\n              console.log(\"forbidden\");\n            }\n\n            break;\n\n          case \"certainty\":\n            setInflectTarget(target);\n            break;\n\n          case \"importance\":\n            setInflectTarget(target);\n            break;\n\n          default:\n            setInfo(null); //clear InfoBox\n\n            setInfo({\n              position: [e.x, e.y],\n              target: target,\n              dimensions: dimensions\n            });\n          //displays instant properties when clicked\n        } // if (toggle===\"cancelled\") {\n        //   const newInstants = [...data];\n        //   const instant = newInstants.find(n => n.id === target.id);\n        //   instant.cancelled = true;\n        //   setData(newInstants);\n        // } else if (){\n        //\n        // } else if (toggle===\"connection\") {\n        //   const newOrder = [...syntacticOrder];\n        //   if (newOrder[2]===0) { //set 2nd selection\n        //     newOrder[1] = target;\n        //     newOrder[2] = 1;\n        //   } else { //set 1st selection\n        //     newOrder[0] = target;\n        //     newOrder[2] = 0;\n        //   }\n        //   setSyntacticOrder(newOrder);\n        // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //     const newInstants = [...data];\n        //     const instant = newInstants.find(n => n.id === target.id);\n        //     instant.foreshadowing = true;\n        //     setData(newInstants);\n        //   } else { //otherwise, change mouse to no symbol\n        //     console.log(\"forbidden\");\n        //   }\n        // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n        //   setInflectTarget(target);\n        // } else {\n        //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        // }\n\n\n        e.stopPropagation(); //stops deselect when bg is clicked\n      });\n      /*//---draw inflections---//\r\n        //--draw connetion inflection--//\r\n      //circle around instant\r\n      svg\r\n        .selectAll(\".connections\")\r\n        .data(activeData.filter(d => d.connections))\r\n        .join(\"circle\")\r\n        .raise()\r\n        .attr(\"class\", \"connections pointer\")\r\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"black\")\r\n        .attr(\"stroke-dasharray\", \"3\")\r\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\r\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\r\n        .attr(\"cy\", d => yScale(d.y));\r\n        //link connecting circles\r\n      const ctLinker = linkHorizontal()\r\n        .source(instant => data.find(x => x.id === instant.id))\r\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\r\n        // .target(() => {\r\n        //   //layerX, layerY\r\n        //   const y = yScaleInverse(499);\r\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\r\n        //   return {x: x, y: y}\r\n        // })\r\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\r\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\r\n        .y(d => d.scale ? yScale(d.y) : d.y);\r\n      svg\r\n        .selectAll(\".connectionLinks\")\r\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\r\n        .join(\"path\")\r\n        .raise()\r\n        .attr(\"class\", \"connectionLinks pointer\")\r\n        .attr(\"d\", ctLinker)\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"black\")\r\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\r\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\r\n        .attr(\"stroke-dasharray\", \"3\")\r\n      */\n      //initialize custom symbols\n\n      const cancelledSymbol = {\n        draw: (context, size) => {\n          let s = Math.sqrt(size) / 2;\n          context.moveTo(s, 0);\n          context.lineTo(s * 2, s);\n          context.lineTo(s, s * 2);\n          context.lineTo(0, s);\n          context.lineTo(-s, s * 2);\n          context.lineTo(-s * 2, s);\n          context.lineTo(-s, 0);\n          context.lineTo(-s * 2, -s);\n          context.lineTo(-s, -s * 2);\n          context.lineTo(0, -s);\n          context.lineTo(s, -s * 2);\n          context.lineTo(s * 2, -s);\n          context.closePath();\n        }\n      };\n      /*\r\n      //foreshadowing symbol\r\n      const fsSymbol = {\r\n        draw: (context, size) => {\r\n          let s = size;\r\n              context.moveTo(0,0);\r\n              context.lineTo(s*2,s/2);\r\n              context.lineTo(s*2,-s/2);\r\n              context.closePath();\r\n        }\r\n      };\r\n      //foreshadowing gradient\r\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\r\n      .attr(\"id\", \"fsgradient\")//id of the gradient\r\n      .attr(\"x1\", \"0%\")\r\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\r\n      .attr(\"y1\", \"0%\")\r\n      .attr(\"y2\", \"0%\");\r\n        fsg.append(\"stop\")\r\n      .attr(\"offset\", \"0%\")\r\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\r\n      .style(\"stop-opacity\", 1);\r\n        fsg.append(\"stop\")\r\n      .attr(\"offset\", \"100%\")\r\n      .style(\"stop-color\", \"black\")//end in transparent\r\n      .style(\"stop-opacity\", 0);\r\n      */\n      //---draw symbols---//\n      //TODO: doesn't display if cancelled is true from the start\n      // .attr(\"cx\", ([,v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\n      // .attr(\"cy\", ([,v]) => yScale(v.y))\n\n      svg.selectAll(\".cancelled\").data(activeData.filter(_ref23 => {\n        let [, v] = _ref23;\n        return v.cancelled;\n      })).join(\"path\").raise().attr(\"class\", \"cancelled pointer\").attr(\"d\", symbol(cancelledSymbol, radius * radius * 5)).attr(\"fill\", _ref24 => {\n        let [, v] = _ref24;\n        return v.color ? v.color : \"black\";\n      }) //if it has a color other than black, use that\n      .attr(\"transform\", _ref25 => {\n        let [, v] = _ref25;\n        return `translate(${xScales[v.scale[0]].scale(v.x)}, ${yScale(v.y)})`;\n      }).on(\"click\", (e, target) => {\n        if (toggle === \"cancelled\") {\n          const newData = { ...data\n          };\n          newData[target[0]].cancelled = false;\n          updateSrc(newData);\n        } else {\n          setInfo({\n            position: [e.x, e.y],\n            target: target\n          }); //displays instant properties when clicked\n        }\n\n        e.stopPropagation();\n      });\n      /*\r\n            //---draw foreshadowing---//\r\n            svg\r\n              .selectAll(\".foreshadowing\")\r\n              .data(activeData.filter(d => d.foreshadowing))\r\n              .join(\"path\")\r\n              .raise()\r\n              .attr(\"class\", \"foreshadowing pointer\")\r\n              .attr(\"d\", symbol(fsSymbol, radius*radius*5))\r\n              .style(\"fill\", \"url(#fsgradient)\")\r\n              .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\r\n              .on(\"click\", (e, target) => {\r\n                if (toggle===\"foreshadowing\") {\r\n                  const newInstants = [...data];\r\n                  const instant = newInstants.find(n => n.id === target.id);\r\n                  delete instant.foreshadowing;\r\n                  setData(newInstants);\r\n                } else {\r\n                  setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\r\n                }\r\n                setToggle(null);\r\n                e.stopPropagation();\r\n              });\r\n      */\n      //---draw labels---//\n      // svg\n      //   .selectAll(\".zonesLabel\")\n      //   .data(zones)\n      //   .join(\"text\")\n      //   .attr(\"class\", \"zonesLabel\")\n      //   .text(v => v.text)\n      //   .attr(\"x\", v => xScales[v.scale].scale(v.start))\n      //   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\n      //   .attr(\"text-anchor\", \"middle\");\n\n      svg.selectAll(\".label\").data(activeData.filter(_ref26 => {\n        let [, v] = _ref26;\n        return !isNaN(v.x);\n      })).join(\"text\").attr(\"class\", \"label\").text(_ref27 => {\n        let [k, v] = _ref27;\n        return showLabel ? v.text : v.id;\n      }).attr(\"x\", _ref28 => {\n        let [k, v] = _ref28;\n        return xScales[v.scale[0]].scale(v.x);\n      }).attr(\"y\", _ref29 => {\n        let [k, v] = _ref29;\n        return yScale(v.y - 0.05 * rangeY);\n      }) //vertical offset. see scales\n      .attr(\"text-anchor\", \"middle\"); // .attr(\"font-size\", fontSize);\n\n      svg.selectAll(\".intervalLabel\").data(intervals).join(\"text\").attr(\"class\", \"intervalLabel\").text(v => v.text).attr(\"x\", v => {\n        const source = v.source[1];\n        const target = v.target[1];\n        const thisSourceScale = xScales[source.scale[0]];\n        const thisTargetScale = xScales[target.scale[0]];\n\n        if (!isNaN(source.x) && !isNaN(target.x)) {\n          //scale values, then average them\n          return (thisSourceScale.scale(source.x) + thisTargetScale.scale(target.x)) / 2;\n        } else if (isNaN(source.x)) {\n          //if source is no end/beginning\n          //noEnd or noBeginning?\n          const s = source.x === \"noBeginning\" ? thisSourceScale.scale(thisSourceScale.noBeginning) : thisSourceScale.scale(thisSourceScale.noEnd);\n          return (s + thisTargetScale.scale(target.x)) / 2;\n        } else if (isNaN(target.x)) {\n          //if target is no end/beginning\n          const s = target.x === \"noBeginning\" ? thisTargetScale.scale(thisTargetScale.noBeginning) : thisTargetScale.scale(thisTargetScale.noEnd);\n          return (s + thisSourceScale.scale(source.x)) / 2;\n        }\n      }).attr(\"y\", v => yScale(Math.max(v.source[1].y, v.target[1].y) + 0.05 * rangeY)) //.05 above max y\n      .attr(\"text-anchor\", \"middle\");\n    } //---zoom---//\n\n\n    const zoomBehavior = zoom().scaleExtent([1, 5]) //can zoom 2x smaller and 5x bigger\n    .translateExtent([[-50, 0], [dimensions.width + 50, dimensions.height]]) //limits how far graph can pan\n    .on(\"zoom\", e => {\n      const zoomState = e.transform; //returns zoom transformations as an object\n\n      setCurrentZoomState(zoomState);\n    }); //regular clicking\n\n    svg.on(\"click\", e => {\n      if (toggle === \"addInstant\") {\n        /*\r\n        if range of zoom > 10, Math.round(x)\r\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\r\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\r\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\r\n        const decimal = scales[activeScale]\r\n        xScales[key].scale\r\n        const decimal = scales[activeScale]\r\n        */\n        //TODO: zoom range matches up with current zoom\n        const zoomRange = xScales[activeScale[0]].scale.domain()[1] - xScales[activeScale[0]].scale.domain()[0]; //max-min\n        // const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\n\n        const x = xScales[activeScale[0]].scale.invert(e.layerX);\n        const y = yScale.invert(e.layerY); // console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\n\n        setInflectTarget({\n          x: round(x, zoomRange),\n          y: Math.round(y)\n        });\n        setToggle(\"NewInstantForm\");\n      }\n\n      setInfo(null);\n    });\n    svg.call(zoomBehavior);\n  }, [data, setData, zones, activeZones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: wrapperRef,\n    className: \"svgWrapper\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      id: \"graphic\",\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 839,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 838,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Graphic, \"b4CAhwLk9FZLxktZNVY3UOkz6Nw=\", false, function () {\n  return [useResizeObserver];\n});\n\n_c = Graphic;\n;\nexport default Graphic;\n\nvar _c;\n\n$RefreshReg$(_c, \"Graphic\");","map":{"version":3,"names":["React","useState","useEffect","useRef","select","scaleLinear","scaleOrdinal","axisBottom","axisLeft","linkHorizontal","format","drag","zoom","min","max","symbol","symbols","useResizeObserver","generateIntervals","Graphic","data","setData","updateSrc","activeLayer","zones","setZones","radius","info","setInfo","setInflectTarget","showLabel","toggle","setToggle","scales","setScales","syntacticOrder","setSyntacticOrder","activeScale","activeData","Object","entries","activeZones","logic","length","isNaN","x","svgRef","wrapperRef","dimensions","currentZoomState","setCurrentZoomState","yScales","yTicks","v","push","y","forEach","k","scale","domain","height","range","ticks","Set","intervals","svg","current","selectAll","remove","round","value","precision","Math","log10","floor","pow","logicScale","unknown","breakpoint","xMin","map","key","xMax","yMin","yMax","rangeX","rangeY","xInverse","currentScale","width","xDrag","xScales","fromEntries","thisScale","noBeginning","noEnd","hasSegments","segments","hideLabel","yPos","label","units","tickValues","scaleInverse","xSegments","keys","i","n","proportion","segment","newXScale","rescaleX","newMin","newMax","yScale","yScaleInverse","yScaleInverseDrag","join","attr","start","end","opacity","color","importance","on","e","target","position","type","stopPropagation","text","tickSize","append","style","call","raise","g","d","xAxis","concat","tickFormat","yAxis","hideLabels","dragged","dx","subject","dy","newInstants","console","log","intervaler","source","interval","dashed","newOrder","layerX","layerY","newData","cancelled","instant","find","id","foreshadowing","cancelledSymbol","draw","context","size","s","sqrt","moveTo","lineTo","closePath","filter","thisSourceScale","thisTargetScale","zoomBehavior","scaleExtent","translateExtent","zoomState","transform","zoomRange","invert"],"sources":["C:/Users/Sumac/Documents/GitHub/chronovis-paintbox/src/components/Graphic.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { select, scaleLinear, scaleOrdinal, axisBottom, axisLeft, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\r\nimport useResizeObserver from \"./useResizeObserver\";\r\nimport generateIntervals from \"./generateIntervals\";\r\n\r\nfunction Graphic({\r\n  data, setData,\r\n  updateSrc,\r\n  activeLayer,\r\n  zones, setZones,\r\n  radius,\r\n  info, setInfo,\r\n  setInflectTarget,\r\n  showLabel,\r\n  toggle, setToggle,\r\n  scales, setScales,\r\n  syntacticOrder, setSyntacticOrder,\r\n  activeScale\r\n}) {\r\n\r\n  //all data is passed down from and synced to App.js\r\n  const activeData = Object.entries(data); //convert json to array for faster processing\r\n  const activeZones = Object.entries(zones);\r\n  //TODO: layers\r\n  // const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\r\n\r\n\r\n\r\n\r\n  //is logical operators active?\r\n  const logic = data.length? isNaN(data[0].x): null; //TODO: refine logical operators\r\n\r\n  //initialize reference object to pass to svg in React Dom\r\n  const svgRef = useRef();\r\n  //svg wrapped in div bc otherwise resize observer callback won't work\r\n  const wrapperRef = useRef();\r\n  const dimensions = useResizeObserver(wrapperRef);\r\n  const [currentZoomState, setCurrentZoomState] = useState();\r\n\r\n  //hash map of y scales\r\n  const yScales = {};\r\n\r\n  //init scales. turn into useRef eventually\r\n  useEffect(() => {\r\n    if (!dimensions) return;\r\n    const yTicks = [];\r\n\r\n    for (let v of activeData) {\r\n      yTicks.push(activeData.y);\r\n    }\r\n\r\n    Object.entries(scales.y).forEach(([k, v]) => {\r\n      yScales[k]= {\r\n        scale: scaleLinear()\r\n        .domain([0, dimensions.height])\r\n        .range([v.min, v.max]),\r\n        drag: scaleLinear()\r\n        .domain([-dimensions.height, dimensions.height])\r\n        .range([-(v.max-v.min), (v.max-v.min)]),\r\n        ticks: [...new Set(yTicks)]\r\n      }\r\n    });\r\n  }, [dimensions, scales, currentZoomState, data]);\r\n\r\n  //initialize intervals between instants\r\n  const intervals = generateIntervals(data); //TODO: write updateIntervals function\r\n\r\n  //initialize variables\r\n  /*\r\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\r\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\r\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\r\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\r\n  */\r\n\r\n  //all d3 shennanigans goes in this hook. called initially and on every data change\r\n  useEffect(() => {\r\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\r\n    //prevents crashing when useResizeObserver returns null before svg is rendered\r\n    if (!dimensions) return;\r\n    //removes svgs added using append()\r\n    svg\r\n      .selectAll(\".remove\")\r\n      .remove();\r\n    //removes\r\n    if (!activeData.length) {\r\n      svg\r\n        .selectAll(\".instant\")\r\n        .remove();\r\n      svg\r\n        .selectAll(\".interval\")\r\n        .remove();\r\n      svg\r\n        .selectAll(\".label\")\r\n        .remove();\r\n      svg\r\n        .selectAll(\".intervalLabel\")\r\n        .remove();\r\n\r\n    } else if (!activeZones.length) {\r\n      svg\r\n        .selectAll(\".zones\")\r\n        .remove();\r\n      svg\r\n        .selectAll(\".zonesLabel\")\r\n        .remove();\r\n    }\r\n\r\n    //rounding for data inputted thru paintbox interface\r\n    function round(value, range) {\r\n      const precision = Math.log10(range)<1 ? -(Math.floor(Math.log10(range)-1)) : 0;\r\n      return Math.round(value*Math.pow(10, precision))/ Math.pow(10, precision)\r\n    }\r\n\r\n\r\n    //---scales---//\r\n\r\n    //if time matches logical operator keyword, translate into index values, then map\r\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\r\n\r\n    const breakpoint = 5;\r\n\r\n\r\n    const xMin = min(activeData.map(([key, {x}]) => logic ? logicScale(x) : x));\r\n    const xMax = max(activeData.map(([key, {x}]) => logic ? logicScale(x) : x));\r\n    // const yMin = min(Object.entries(data).map(([key, {y}]) => y));\r\n    // const yMax = max(Object.entries(data).map(([key, {y}]) => y));\r\n    const yTicks = activeData.map(([,{y}]) => y);\r\n    const yMin = scales.y[activeScale[1]].min;\r\n    const yMax = scales.y[activeScale[1]].max;\r\n    const rangeX = xMax-xMin; //0 is minX, 1 is maxX (reference findMinMax)\r\n    const rangeY = yMax-yMin;\r\n\r\n\r\n    /*\r\n    - Allow users to specify scale. x&y min max and units label\r\n    - for each scale, generateScale()\r\n    */\r\n\r\n    // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\r\n    //\r\n    //   const xInverse = scaleLinear()\r\n    //     .domain([0, dimensions.width])\r\n    //     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\r\n    //   const xDrag = scaleLinear()\r\n    //     .domain([-dimensions.width, dimensions.width])\r\n    //     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\r\n    //   const yInverse = scaleLinear()\r\n    //     .domain([-dimensions.height, dimensions.height])\r\n    //     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\r\n    //\r\n    //\r\n    //   return {\r\n    //     xInverse, xDrag, yInverse\r\n    //   };\r\n    // }\r\n    const xInverse = (currentScale) => scaleLinear()\r\n      .domain([0, dimensions.width])\r\n      .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\r\n    const xDrag = (currentScale) => scaleLinear()\r\n      .domain([-dimensions.width, dimensions.width])\r\n      .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\r\n    // const yInverse = scaleLinear()\r\n    //   .domain([-dimensions.height, dimensions.height])\r\n    //   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\r\n\r\n\r\n    //scales values to screen pixels\r\n    /*\r\n    {\r\n      biggie: {\r\n        ...\r\n        scale: generateScale()\r\n      }\r\n      ...\r\n    }\r\n    */\r\n\r\n    /*\r\n    xScale =\r\n    {\r\n\r\n  }\r\n    */\r\n\r\n\r\n    //TODO: fromEntries & entries not compatible with some older browsers\r\n    const xScales = Object.fromEntries( //for every scale in scales data, generate an xScale\r\n      Object.entries(scales.x).map(([key, thisScale]) => [\r\n        key,\r\n        {\r\n          scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\r\n            .domain([thisScale.min, thisScale.max])\r\n            .range([0, dimensions.width]),\r\n          noBeginning: thisScale.min-0.1*(thisScale.max-thisScale.min),\r\n          noEnd: thisScale.max+0.1*(thisScale.max-thisScale.min),\r\n          hasSegments: thisScale.segments.length?true:false,\r\n          hideLabel: thisScale.hideLabel,\r\n          yPos: 1-thisScale.yPos,\r\n          label: `${key} (${thisScale.units})`,\r\n          tickValues: thisScale.tickValues?thisScale.tickValues:null,\r\n          scaleInverse: scaleLinear() //for NewInstantForm\r\n            .domain([0, dimensions.width])\r\n            .range([thisScale.min, thisScale.max])\r\n        }\r\n      ])\r\n    );\r\n\r\n    const xSegments = () => {\r\n      const segments = [];\r\n      Object.keys(scales.x).forEach((key, i) => {\r\n        const thisScale = scales.x[key];\r\n        // const segments = [];\r\n        if (!thisScale.segments.length) {\r\n          return;\r\n        }\r\n        thisScale.segments.map(n => {\r\n          const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\r\n          const max = n.max?n.max:thisScale.max;\r\n          // console.log(xScales[i].scale(min));\r\n          segments.push({\r\n            scale: key,\r\n            yPos: 1-thisScale.yPos,\r\n            proportion: (max-min)/(thisScale.max-thisScale.min),\r\n            segment: scaleLinear()\r\n            .domain([min, max])\r\n            .range([xScales[key].scale(min), xScales[key].scale(max)])\r\n          })\r\n        })\r\n      });\r\n      return segments;\r\n    }\r\n\r\n\r\n    /*\r\n      xScales(generateScales(scaleLinear(scale)))\r\n      - take xScale and rescale according to transformations (newXScale)\r\n      - update each array entry's domain with that of newXScale\r\n    */\r\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\r\n    if (currentZoomState) {\r\n      Object.entries(xScales).forEach(([key,thisScale]) => {\r\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\r\n        const newMin = newXScale.domain()[0]\r\n        const newMax = newXScale.domain()[1];\r\n\r\n        //applies zoom transformations to scale + scaleInverse\r\n        xScales[key].scale = newXScale;\r\n      });\r\n\r\n\r\n    };\r\n    // const xScale = scaleLinear()\r\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\r\n    //   .range([0, dimensions.width]);\r\n    const yScale = scaleLinear()\r\n      //if difference in y vaules greater than 5, resize to min and max\r\n      // .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\r\n      .domain([yMin, yMax])\r\n      .range([dimensions.height,0]);\r\n    //inverse scales for drag behavior\r\n    // const xScaleInverse = scaleLinear()\r\n    //   .domain([-dimensions.width, dimensions.width])\r\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\r\n    const yScaleInverse = scaleLinear()\r\n      .domain([0, dimensions.height])\r\n      .range([yMin, yMax])\r\n      // .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\r\n    const yScaleInverseDrag = scaleLinear()\r\n      .domain([dimensions.height, -dimensions.height])\r\n      .range([-rangeY, rangeY])\r\n      // .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\r\n\r\n\r\n    if (Object.entries(zones).length) {\r\n      svg\r\n      .selectAll(\".zones\")\r\n      .data(activeZones)\r\n      .join(\"rect\")\r\n      .attr(\"class\", \"zones pointer\")\r\n      .attr(\"x\", ([, v]) => xScales[v.scale[0]].scale(v.start))\r\n      // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\r\n      .attr(\"y\", ([, v]) => yScale(yMax))\r\n      // .attr(\"y\", ([, v]) => v.yStart ? yScale(v.yStart) : yMin-10) //TODO: if no yStart, minimum y value\r\n      .attr(\"width\", ([, v]) => xScales[v.scale[0]].scale(v.end) - xScales[v.scale[0]].scale(v.start))\r\n      .attr(\"height\", ([, v]) => {\r\n        return (yScale(yMin))\r\n        // if (v.yStart & v.yEnd) {\r\n        //   return (yScale(v.yStart)-yScale(v.yEnd))\r\n        // } else if (v.yStart) {\r\n        //   return (yScale(v.yStart)-yScale(yMax-10))\r\n        // } else {\r\n        //   return (yScale(yMax-10)) //TODO: if no yStart, minimum y value\r\n        //   // return (yScale(minMax[3])-yScale(minMax[2]))\r\n        // }\r\n      })\r\n      .attr(\"opacity\", ([k, v]) => v.opacity ? v.opacity : 0.5)\r\n      .attr(\"fill\", ([k, v]) => v.color ? v.color : \"#999\")\r\n      .attr(\"stroke\", \"black\") //TODO: stroke be different colors\r\n      .attr(\"stroke-width\", ([k, v]) => v.importance ? v.importance*2 : 0)\r\n      .on(\"click\", (e, target) => {\r\n        if (toggle===\"certainty\" || toggle===\"importance\") { //pulls up inflection menu\r\n          setInflectTarget(target);\r\n        } else if (toggle!==\"pan\" || toggle!==\"addInstant\"){ //displays zone properties when clicked\r\n          setInfo(null); //clear InfoBox\r\n          setInfo({position: [e.x, e.y], target: target, type: \"zone\", dimensions: dimensions});  //TODO: set info to null when clicking same zone again\r\n        }\r\n        e.stopPropagation();\r\n      });\r\n\r\n      svg\r\n        .selectAll(\".zonesLabel\")\r\n        .data(activeZones)\r\n        .join(\"text\")\r\n        .attr(\"class\", \"zonesLabel\")\r\n        .text(([k,v]) => v.text)\r\n        .attr(\"opacity\", 0.5)\r\n        .attr(\"x\", ([, v]) => xScales[v.scale[0]].scale(v.start)+10)\r\n        .attr(\"y\", yScale(yMax)+30) //.05 above max y\r\n        .attr(\"text-anchor\", \"bottom\");\r\n    }\r\n\r\n    //---draw bottom axis---//\r\n\r\n    xSegments().forEach(n => {\r\n      //TODO: push all the axis ticks() values into an array\r\n      // [...new Set(segments)]\r\n      //draw from there\r\n      const segment = axisBottom(n.segment)\r\n      // .ticks(n.proportion<.33?5:null, \"f\");\r\n      .ticks(null, \"f\")\r\n      .tickSize(-dimensions.height); //TODO\r\n\r\n      svg\r\n        .append(\"g\")\r\n        .attr(\"class\", \"remove\")\r\n        .style(\"transform\", `translateY(${dimensions.height*n.yPos}px)`)\r\n        .call(segment)\r\n        .raise()\r\n        .call(g => g.select(\".domain\") //removes solid black axis bar\r\n          .remove())\r\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\r\n          .attr(\"stroke-opacity\", 0.25))\r\n        .call(g => g.selectAll(\".tick text\")\r\n          .attr(\"y\", 10)\r\n          .attr(\"opacity\", (d, i) => { //TODO: remove instead of setting opacity to 0\r\n            if ((n.proportion<.25)&&(i%3)) { //less than 1/4, label every 3 ticks\r\n              return 0;\r\n            } else if ((n.proportion<.33)&&(i%2)) { //less than 1/3, label every other tick\r\n              return 0;\r\n            } else {\r\n              return 0.5\r\n            }\r\n          })\r\n        );\r\n    });\r\n\r\n    Object.entries(xScales).forEach(([key,thisScale]) => {\r\n      const xAxis = axisBottom(thisScale.scale)\r\n      .tickValues(thisScale.scale.ticks().concat(scales.x[key].min, scales.x[key].max)) //pass in autogenerated tick values + min and max values\r\n      .tickFormat(format(''))\r\n      .tickSize(-dimensions.height);\r\n      // console.log(thisScale.scale.ticks())\r\n\r\n      if (!thisScale.hasSegments) {\r\n        svg\r\n          .append(\"g\")\r\n          .attr(\"class\", \"remove\")\r\n          .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\r\n          .call(xAxis)\r\n          .raise()\r\n          .call(g => g.select(\".domain\") //removes solid black axis bar\r\n            .remove())\r\n          .call(g => g.selectAll(\".tick line\") //styles individual ticks\r\n            .attr(\"stroke-opacity\", 0.25))\r\n          .call(g => g.selectAll(\".tick text\")\r\n            .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\r\n            .attr(\"opacity\", 0.5));\r\n      }\r\n      if (!thisScale.hideLabel) {\r\n        svg\r\n          .append(\"text\")\r\n          .text(thisScale.label)\r\n          .attr(\"class\", \"axisLabel smallTxt remove\")\r\n          .attr(\"x\", dimensions.width/2)\r\n          .attr(\"y\", dimensions.height*(thisScale.yPos+.07))\r\n          .attr(\"text-anchor\", \"middle\")\r\n          .attr(\"opacity\", 0.5);\r\n        }\r\n      }\r\n    );\r\n\r\n    //--draw vertical axis--//\r\n\r\n    const yAxis = axisLeft(yScale)\r\n    .tickValues([...new Set(yTicks), scales.y[activeScale[1]].min, scales.y[activeScale[1]].max]) //reg mode\r\n    .tickFormat(format(''))\r\n\r\n    svg\r\n      .append(\"g\")\r\n      .attr(\"class\", \"remove\")\r\n      // .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\r\n      .call(yAxis)\r\n      .raise()\r\n      .call(g => g.select(\".domain\") //removes solid black axis bar\r\n        .remove())\r\n      .call(g => g.selectAll(\".tick line\") //styles individual ticks\r\n        .attr(\"stroke-opacity\", 0.5))\r\n      .call(g => g.selectAll(\".tick text\")\r\n        .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\r\n        .attr(\"opacity\", 0.5));\r\n\r\n    if (!scales.y[activeScale[1]].hideLabels) {\r\n      svg\r\n        .append(\"text\")\r\n        .text(`${activeScale[1]} (${scales.y[activeScale[1]].units})`)\r\n        .attr(\"class\", \"axisLabel smallTxt remove\")\r\n        // .attr(\"x\", dimensions.width/2)\r\n        // .attr(\"y\", dimensions.height/2)\r\n        .attr(\"text-anchor\", \"middle\")\r\n        .attr(\"transform\", `translate(-30,${dimensions.height/2})rotate(-90)`)\r\n        .attr(\"opacity\", 0.5);\r\n    }\r\n\r\n    //--drag behavior--//\r\n    const dragged = drag()\r\n      // .on(\"start\", e => {\r\n      //   select(this).attr(\"stroke\", \"black\");\r\n      // })\r\n      .on(\"drag\", e => {\r\n        //TODO: extract precision function to round new pos\r\n        const dx = xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx);\r\n        // const dx = xScales.scaleInverse\r\n        const dy = yScaleInverseDrag(e.dy);\r\n        const newInstants = {...data}; //always make a copy when updating array\r\n\r\n        //find array element in data with matching ID and set new x y coordinates\r\n        newInstants[e.subject[0]].x += dx;\r\n        newInstants[e.subject[0]].y += dy;\r\n\r\n        setData(newInstants);\r\n      }) //TODO: unify onEnd and onClick\r\n      .on(\"end\", e => {\r\n        console.log(\"end\");\r\n      });\r\n\r\n    if (activeData.length) {\r\n      //---draw intervals---//\r\n      const intervaler = linkHorizontal()\r\n        .source(interval => interval.source[1])\r\n        .target(interval => interval.target[1])\r\n        // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\r\n        .x(v => {\r\n            const thisScale = xScales[v.scale[0]]\r\n            if (!isNaN(v.x)) {\r\n              return thisScale.scale(v.x)\r\n            } else if (v.x===\"noEnd\") {\r\n              return thisScale.scale(thisScale.noEnd)\r\n            } else if (v.x===\"noBeginning\") {\r\n              return thisScale.scale(thisScale.noBeginning)\r\n            }\r\n        })\r\n        .y(v => yScale(v.y));\r\n\r\n      svg\r\n        .selectAll(\".interval\")\r\n        .data(intervals)\r\n        .join(\"path\")\r\n        .raise()\r\n        .attr(\"class\", \"interval pointer\")\r\n        .attr(\"d\", intervaler)\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", n => n.color? n.color : \"black\")\r\n        .attr(\"stroke-width\", n => n.width ? n.width : radius)\r\n        .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\r\n        .attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null)\r\n        .on(\"click\", (e, target) => {\r\n          if (toggle===\"connection\") {\r\n            const newOrder = [...syntacticOrder];\r\n            if (newOrder[2]===0) { //set 2nd selection\r\n              newOrder[1] = {x:xInverse(scales.x[activeScale[0]])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale}; //scale TODO\r\n              newOrder[2] = 1;\r\n            } else { //set 1st selection\r\n              newOrder[0] = {x:xInverse(scales.x[activeScale[0]])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale};\r\n              newOrder[2] = 0;\r\n            }\r\n            setSyntacticOrder(newOrder);\r\n          }\r\n          //else if (toggle===\"foreshadowing\") {\r\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\r\n          //\r\n          //\r\n          //   } else { //otherwise, change mouse to no symbol\r\n          //\r\n          //   }\r\n          //   //option to adjust gradient eventually\r\n          // } else\r\n          else if (toggle===\"certainty\" || toggle===\"importance\") {\r\n            setInflectTarget(target);\r\n          } else {\r\n            setInfo(null); //clear InfoBox\r\n            setInfo({position: [e.x, e.y], target: target, type: \"interval\", dimensions: dimensions}); //displays interval properties when clicked\r\n          }\r\n          e.stopPropagation();\r\n        });\r\n\r\n\r\n\r\n      //---draw instants---//\r\n      svg\r\n        .selectAll(\".instant\")\r\n        // .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\r\n        .data(activeData)\r\n        .join(\"circle\")\r\n        .raise()\r\n        .attr(\"class\", \"instant pointer\")\r\n        .attr(\"r\", ([,v]) => v.radius? v.radius : radius) //TODO: custom radius accessibility\r\n        .attr(\"fill\", ([,v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\r\n        .attr(\"opacity\", ([,v]) => v.opacity ? v.opacity : 1)\r\n        // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\r\n        .attr(\"cx\", ([,v]) => {\r\n          const thisScale = xScales[v.scale[0]];\r\n          /*\r\n          noBeginning: thisScale.min-10,\r\n          noEnd: thisScale.max+10,\r\n          */\r\n          if (!isNaN(v.x)) {\r\n            return thisScale.scale(v.x)\r\n          } else if (v.x===\"noBeginning\"){\r\n            return thisScale.scale(thisScale.noBeginning)\r\n          } else if (v.x===\"noEnd\") {\r\n            return thisScale.scale(thisScale.noEnd)\r\n          }\r\n        }) //scale x coordinate based on xScale defined in instant's scale property\r\n        .attr(\"cy\", ([,v]) => yScale(v.y))\r\n        .call(dragged)\r\n        .on(\"click\", (e, target) => {\r\n          switch (toggle) {\r\n            case \"cancelled\":\r\n              const newData = {...data};\r\n              newData[target[0]].cancelled = true;\r\n              // console.log(newData[target[0]]);\r\n              updateSrc(newData);\r\n              break;\r\n            case \"connection\":\r\n              const newOrder = [...syntacticOrder];\r\n              if (newOrder[2]===0) { //set 2nd selection\r\n                newOrder[1] = target;\r\n                newOrder[2] = 1;\r\n              } else { //set 1st selection\r\n                newOrder[0] = target;\r\n                newOrder[2] = 0;\r\n              }\r\n              setSyntacticOrder(newOrder);\r\n              break;\r\n            case \"foreshadowing\":\r\n              if (!target.target) { //if target is an endpoint, indeterminate end\r\n                const newInstants = [...data];\r\n                const instant = newInstants.find(n => n.id === target.id);\r\n                instant.foreshadowing = true;\r\n                setData(newInstants);\r\n              } else { //otherwise, change mouse to no symbol\r\n                console.log(\"forbidden\");\r\n              }\r\n              break;\r\n            case \"certainty\":\r\n              setInflectTarget(target);\r\n              break;\r\n            case \"importance\":\r\n              setInflectTarget(target);\r\n              break;\r\n            default:\r\n              setInfo(null); //clear InfoBox\r\n              setInfo({position: [e.x, e.y], target: target, dimensions: dimensions}); //displays instant properties when clicked\r\n          }\r\n          // if (toggle===\"cancelled\") {\r\n          //   const newInstants = [...data];\r\n          //   const instant = newInstants.find(n => n.id === target.id);\r\n          //   instant.cancelled = true;\r\n          //   setData(newInstants);\r\n          // } else if (){\r\n          //\r\n          // } else if (toggle===\"connection\") {\r\n          //   const newOrder = [...syntacticOrder];\r\n          //   if (newOrder[2]===0) { //set 2nd selection\r\n          //     newOrder[1] = target;\r\n          //     newOrder[2] = 1;\r\n          //   } else { //set 1st selection\r\n          //     newOrder[0] = target;\r\n          //     newOrder[2] = 0;\r\n          //   }\r\n          //   setSyntacticOrder(newOrder);\r\n          // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\r\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\r\n          //     const newInstants = [...data];\r\n          //     const instant = newInstants.find(n => n.id === target.id);\r\n          //     instant.foreshadowing = true;\r\n          //     setData(newInstants);\r\n          //   } else { //otherwise, change mouse to no symbol\r\n          //     console.log(\"forbidden\");\r\n          //   }\r\n          // } else if (toggle===\"certainty\" || toggle===\"importance\"){\r\n          //   setInflectTarget(target);\r\n          // } else {\r\n          //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\r\n          // }\r\n          e.stopPropagation(); //stops deselect when bg is clicked\r\n        });\r\n\r\n      /*//---draw inflections---//\r\n\r\n      //--draw connetion inflection--//\r\n      //circle around instant\r\n      svg\r\n        .selectAll(\".connections\")\r\n        .data(activeData.filter(d => d.connections))\r\n        .join(\"circle\")\r\n        .raise()\r\n        .attr(\"class\", \"connections pointer\")\r\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"black\")\r\n        .attr(\"stroke-dasharray\", \"3\")\r\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\r\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\r\n        .attr(\"cy\", d => yScale(d.y));\r\n\r\n      //link connecting circles\r\n      const ctLinker = linkHorizontal()\r\n        .source(instant => data.find(x => x.id === instant.id))\r\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\r\n        // .target(() => {\r\n        //   //layerX, layerY\r\n        //   const y = yScaleInverse(499);\r\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\r\n        //   return {x: x, y: y}\r\n        // })\r\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\r\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\r\n        .y(d => d.scale ? yScale(d.y) : d.y);\r\n      svg\r\n        .selectAll(\".connectionLinks\")\r\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\r\n        .join(\"path\")\r\n        .raise()\r\n        .attr(\"class\", \"connectionLinks pointer\")\r\n        .attr(\"d\", ctLinker)\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"black\")\r\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\r\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\r\n        .attr(\"stroke-dasharray\", \"3\")\r\n*/\r\n      //initialize custom symbols\r\n      const cancelledSymbol = {\r\n        draw: (context, size) => {\r\n          let s = Math.sqrt(size)/2;\r\n              context.moveTo(s,0);\r\n              context.lineTo(s*2,s);\r\n              context.lineTo(s,s*2);\r\n              context.lineTo(0,s);\r\n              context.lineTo(-s,s*2);\r\n              context.lineTo(-s*2,s);\r\n              context.lineTo(-s,0);\r\n              context.lineTo(-s*2,-s);\r\n              context.lineTo(-s,-s*2);\r\n              context.lineTo(0,-s);\r\n              context.lineTo(s,-s*2);\r\n              context.lineTo(s*2,-s);\r\n              context.closePath();\r\n        }\r\n      };\r\n      /*\r\n      //foreshadowing symbol\r\n      const fsSymbol = {\r\n        draw: (context, size) => {\r\n          let s = size;\r\n              context.moveTo(0,0);\r\n              context.lineTo(s*2,s/2);\r\n              context.lineTo(s*2,-s/2);\r\n              context.closePath();\r\n        }\r\n      };\r\n      //foreshadowing gradient\r\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\r\n      .attr(\"id\", \"fsgradient\")//id of the gradient\r\n      .attr(\"x1\", \"0%\")\r\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\r\n      .attr(\"y1\", \"0%\")\r\n      .attr(\"y2\", \"0%\");\r\n\r\n      fsg.append(\"stop\")\r\n      .attr(\"offset\", \"0%\")\r\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\r\n      .style(\"stop-opacity\", 1);\r\n\r\n      fsg.append(\"stop\")\r\n      .attr(\"offset\", \"100%\")\r\n      .style(\"stop-color\", \"black\")//end in transparent\r\n      .style(\"stop-opacity\", 0);\r\n*/\r\n      //---draw symbols---//\r\n      //TODO: doesn't display if cancelled is true from the start\r\n      // .attr(\"cx\", ([,v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\r\n      // .attr(\"cy\", ([,v]) => yScale(v.y))\r\n      svg\r\n        .selectAll(\".cancelled\")\r\n        .data(activeData.filter(([,v]) => v.cancelled))\r\n        .join(\"path\")\r\n        .raise()\r\n        .attr(\"class\", \"cancelled pointer\")\r\n        .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\r\n        .attr(\"fill\", ([,v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\r\n        .attr(\"transform\", ([,v]) => `translate(${xScales[v.scale[0]].scale(v.x)}, ${yScale(v.y)})`)\r\n        .on(\"click\", (e, target) => {\r\n          if (toggle===\"cancelled\") {\r\n            const newData = {...data};\r\n            newData[target[0]].cancelled = false;\r\n            updateSrc(newData);\r\n          } else {\r\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\r\n          }\r\n          e.stopPropagation();\r\n        });\r\n/*\r\n      //---draw foreshadowing---//\r\n      svg\r\n        .selectAll(\".foreshadowing\")\r\n        .data(activeData.filter(d => d.foreshadowing))\r\n        .join(\"path\")\r\n        .raise()\r\n        .attr(\"class\", \"foreshadowing pointer\")\r\n        .attr(\"d\", symbol(fsSymbol, radius*radius*5))\r\n        .style(\"fill\", \"url(#fsgradient)\")\r\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\r\n        .on(\"click\", (e, target) => {\r\n          if (toggle===\"foreshadowing\") {\r\n            const newInstants = [...data];\r\n            const instant = newInstants.find(n => n.id === target.id);\r\n            delete instant.foreshadowing;\r\n            setData(newInstants);\r\n          } else {\r\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\r\n          }\r\n          setToggle(null);\r\n          e.stopPropagation();\r\n        });\r\n*/\r\n      //---draw labels---//\r\n      // svg\r\n      //   .selectAll(\".zonesLabel\")\r\n      //   .data(zones)\r\n      //   .join(\"text\")\r\n      //   .attr(\"class\", \"zonesLabel\")\r\n      //   .text(v => v.text)\r\n      //   .attr(\"x\", v => xScales[v.scale].scale(v.start))\r\n      //   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\r\n      //   .attr(\"text-anchor\", \"middle\");\r\n\r\n      svg\r\n        .selectAll(\".label\")\r\n        .data(activeData.filter(([,v]) => !isNaN(v.x)))\r\n        .join(\"text\")\r\n        .attr(\"class\", \"label\")\r\n        .text(([k,v]) => showLabel ? v.text : v.id)\r\n        .attr(\"x\", ([k,v]) => xScales[v.scale[0]].scale(v.x))\r\n        .attr(\"y\", ([k,v]) => yScale(v.y-0.05*rangeY)) //vertical offset. see scales\r\n        .attr(\"text-anchor\", \"middle\");\r\n        // .attr(\"font-size\", fontSize);\r\n\r\n      svg\r\n        .selectAll(\".intervalLabel\")\r\n        .data(intervals)\r\n        .join(\"text\")\r\n        .attr(\"class\", \"intervalLabel\")\r\n        .text(v => v.text)\r\n        .attr(\"x\", v => {\r\n          const source=v.source[1];\r\n          const target=v.target[1];\r\n          const thisSourceScale = xScales[source.scale[0]];\r\n          const thisTargetScale = xScales[target.scale[0]];\r\n          if (!isNaN(source.x) && !isNaN( target.x)) {\r\n            //scale values, then average them\r\n            return (thisSourceScale.scale(source.x)+thisTargetScale.scale(target.x))/2\r\n          } else if (isNaN(source.x)) { //if source is no end/beginning\r\n            //noEnd or noBeginning?\r\n            const s = source.x===\"noBeginning\"?thisSourceScale.scale(thisSourceScale.noBeginning):thisSourceScale.scale(thisSourceScale.noEnd)\r\n            return (s+thisTargetScale.scale(target.x))/2\r\n          } else if (isNaN(target.x)) { //if target is no end/beginning\r\n            const s = target.x===\"noBeginning\"?thisTargetScale.scale(thisTargetScale.noBeginning):thisTargetScale.scale(thisTargetScale.noEnd)\r\n            return (s+thisSourceScale.scale(source.x))/2\r\n          }\r\n        })\r\n        .attr(\"y\", v => yScale(Math.max(v.source[1].y, v.target[1].y)+0.05*rangeY)) //.05 above max y\r\n        .attr(\"text-anchor\", \"middle\");\r\n\r\n    }\r\n\r\n\r\n\r\n    //---zoom---//\r\n    const zoomBehavior = zoom()\r\n      .scaleExtent([1, 5]) //can zoom 2x smaller and 5x bigger\r\n      .translateExtent([[-50, 0], [dimensions.width+50, dimensions.height]]) //limits how far graph can pan\r\n      .on(\"zoom\", e => {\r\n        const zoomState = e.transform; //returns zoom transformations as an object\r\n        setCurrentZoomState(zoomState);\r\n      });\r\n\r\n    //regular clicking\r\n    svg.on(\"click\", (e) => {\r\n      if (toggle===\"addInstant\") {\r\n        /*\r\n        if range of zoom > 10, Math.round(x)\r\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\r\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\r\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\r\n        const decimal = scales[activeScale]\r\n        xScales[key].scale\r\n        const decimal = scales[activeScale]\r\n        */\r\n        //TODO: zoom range matches up with current zoom\r\n        const zoomRange = xScales[activeScale[0]].scale.domain()[1] - xScales[activeScale[0]].scale.domain()[0]; //max-min\r\n        // const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\r\n        const x = xScales[activeScale[0]].scale.invert(e.layerX);\r\n        const y = yScale.invert(e.layerY);\r\n        // console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\r\n        setInflectTarget({x: round(x, zoomRange), y: Math.round(y)});\r\n        setToggle(\"NewInstantForm\");\r\n      }\r\n      setInfo(null)\r\n    });\r\n    svg.call(zoomBehavior);\r\n\r\n  }, [data, setData, zones, activeZones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\r\n\r\n  return (\r\n    <div ref={wrapperRef} className=\"svgWrapper\">\r\n      <svg id=\"graphic\" ref={svgRef}>\r\n      </svg>\r\n    </div>\r\n  );\r\n};\r\n\r\n\r\nexport default Graphic;\r\n"],"mappings":"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D,CAAD,CAAP;UAAyE;QApC7E,CAD0B,CAuC1B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;;QACA6E,CAAC,CAACI,eAAF,GAtE0B,CAsEL;MACtB,CAlGH;MAoGA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MAGM;;MACA,MAAMkC,eAAe,GAAG;QACtBC,IAAI,EAAE,CAACC,OAAD,EAAUC,IAAV,KAAmB;UACvB,IAAIC,CAAC,GAAG/F,IAAI,CAACgG,IAAL,CAAUF,IAAV,IAAgB,CAAxB;UACID,OAAO,CAACI,MAAR,CAAeF,CAAf,EAAiB,CAAjB;UACAF,OAAO,CAACK,MAAR,CAAeH,CAAC,GAAC,CAAjB,EAAmBA,CAAnB;UACAF,OAAO,CAACK,MAAR,CAAeH,CAAf,EAAiBA,CAAC,GAAC,CAAnB;UACAF,OAAO,CAACK,MAAR,CAAe,CAAf,EAAiBH,CAAjB;UACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAhB,EAAkBA,CAAC,GAAC,CAApB;UACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAD,GAAG,CAAlB,EAAoBA,CAApB;UACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAhB,EAAkB,CAAlB;UACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAD,GAAG,CAAlB,EAAoB,CAACA,CAArB;UACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAhB,EAAkB,CAACA,CAAD,GAAG,CAArB;UACAF,OAAO,CAACK,MAAR,CAAe,CAAf,EAAiB,CAACH,CAAlB;UACAF,OAAO,CAACK,MAAR,CAAeH,CAAf,EAAiB,CAACA,CAAD,GA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"},"metadata":{},"sourceType":"module"}